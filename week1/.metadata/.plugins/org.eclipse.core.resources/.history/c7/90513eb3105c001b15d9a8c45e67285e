package com.revature.collections;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/*
 * Why Collections?
 * 
 * Previously we've learned about Arrays, which are fixed non-primitive collections of elements
 */
public class CollectionDriver {

	public static void main(String[] args) {
		
		// an example of an integer array
		int[] numbers = {1, 2, 3, 4, 5};
		String[] words = {"This", "is", "a", "String", "Array"};
		// an array is an object
		numbers[1] = 2003;
		System.out.println("The amount of Strings in my String array is " + words.length);
		
		// print out the number at index 3
		System.out.println(numbers[3]);
		
		
		// we could work with this Array like so:
		// we could create a for loop and print out each element
		for (int i=0; i<numbers.length; i++) {
			
			System.out.println(numbers[i]);
		}
		
		/*
		 * The Problem with arrays is that they are STATIC! ...meaning we can't change them
		 * We can only store one data type within them and we can't expand Arrays.
		 */
		
		/*
		 * List
		 * 
		 * A list is an ordered Collection.  Lists can contain duplicate elements within them
		 * We can add more elements (or objects to a list).
		 * 
		 * 	+ Search
		 * 		- searches for a specific object within the collection.
		 * 
		 */
		
		List<Integer> nums = new ArrayList<Integer>(); // Here I am INFERRING GENERICS
		// I am telling the Collection (which is ArrayList) what type of Object it can store.
		nums.add(4);
		nums.add(8);
		nums.add(7);
		
		System.out.println(nums);
		
		User u = new User("James", "Bond", "james007", "p4ssw0rd", "jbond@gmail.com");
		
		User u2 = new User("hulk24", "1r34", "bb@gmail");
		
//		System.out.println(u.getLastName());
		System.out.println(u);
		System.out.println(u2);
		
		// let's create an ArrayList of Users
		List<User> users = new ArrayList<User>();
//		System.out.println(users);
		users.add(u);
		users.add(u2);
		users.add(new User("Blake", "Kruppa", "bkruppa", "pass", "bk@gmail.com"));
		users.add(new User("Larry", "King", "lk123", "pwd", "lking@gmail.com"));
		users.add(u);
	
		// Enhanced for-loop (for-each loop) is the best  way to traverse a collection
		
		// for (<Type> *each-element* : (within) *The Collection*) {
		//				// the code to do to each-element
		// }
//		for (User e : users ) {
//			e.setFirstName("Tony");
//			e.setLastName("Balongna");
//		}
		
		System.out.println("============================");
		
		//   this is each element    users = the collection 
		for (User individualUser : users) {
			System.out.println(individualUser);
		}
		
		/*
		 * Set
		 * 
		 * A set is a Collection that cannot contain duplicate elements.  
		 * Sets essentially enforces a duplicate restriction by adding a contract of the equals()
		 * and hashcode() method
		 *
		 */
		System.out.println("-----------------------------------------------------------------------");
		
		Set<User> userSet = new HashSet<User>();
		User z = new User("Zafar", "Kahrov", "zkjava", "12345", "zk@yahoo.com");
		
	
		userSet.add(new User("Mary", "Shelley", "ms", "pass", "ms@gmail.com"));
		userSet.add(new User("Jack", "Sparrow", "captainjack", "parrot", "pirate@gmail.com"));
		userSet.add(new User("Bruce", "Wayne", "batman", "bats$$", "batman@gmail.com"));
		userSet.add(new User("Jack", "Sparrow", "captainjack", "parrot", "pirate@gmail.com"));
		userSet.add(new User("Zafar", "Kahrov", "zkjava", "12345", "zk@yahoo.com"));
		userSet.add(z);  // the compiler knows that we can't fool it!
		userSet.add(z); // the compiler knows that z points to the same object
		userSet.add(z);
		// this compiles just fine....
		
		// enhanced for-loop to print out each user
		for (User user : userSet) {
			System.out.println(user);
		}
		

	}

}
